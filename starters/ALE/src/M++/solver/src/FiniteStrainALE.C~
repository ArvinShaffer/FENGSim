#include "FiniteStrainALE.h"
#include "LogarithmicStrain.h"
#include "Remapping.h"

FiniteStrainALEAssemble::FiniteStrainALEAssemble (int _dim) : disc(Discretization(_dim)) {
	dim = _dim;
	Mu = mu;
	Lambda = lambda;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			I4.set(i, j, Tensor(i,j));
		}
	}
	ReadConfig(Settings, "Frame", frame);
}

void FiniteStrainALEAssemble::SetH0 (Vector& x0) {
	x0 = 0;
	for (row r = x0.rows(); r != x0.rows_end(); r++) {
	    Point p = h0(r());
	    for (int i = 0; i < dim; i++) {
	        x0(r, i) = p[i];
	    }
	}
}

void FiniteStrainALEAssemble::SetH1 (Vector& x1, double dt) {
	x1 = 0;
	for (row r = x1.rows(); r != x1.rows_end(); r++) {
	    Point p = h1(r(), dt);
	    for (int i = 0; i < dim; i++) {
	        x1(r, i) = p[i];
	    }
	}
}

void FiniteStrainALEAssemble::SetDirichlet (Vector& u, double t) {
	u.ClearDirichletFlags();
	for (cell c = u.GetMesh().cells(); c != u.GetMesh().cells_end(); ++c) {	  
		RowBndValues u_c(u, c);	    
		if (!u_c.onBnd()) continue;
		for (int i = 0; i < c.Faces(); ++i) {
			if (!IsDirichlet(u_c.bc(i))) continue;
			VectorFieldElement E(disc, u, c);
			for (int j = 0; j < disc.NodalPointsOnFace(c,i); ++j) {
				int k = disc.NodalPointOnFace(c, i, j);
				Dirichlet(E[k](), t, k, u_c, u_c.bc(i));
			}
		}
	}
	DirichletConsistent(u);
}

void FiniteStrainALEAssemble::Update (const Vector& _RDisp, Vector& _Tau, Vector& _CStress) {
	for (cell c = _RDisp.GetMesh().cells(); c != _RDisp.GetMesh().cells_end(); c++) {
		VectorFieldElement E(disc, _RDisp, c);
		for (int q = 0; q < E.nQ(); q++) {
			Tensor F = Invert(One - E.VectorGradient(q, _RDisp));
			Tensor f1 = F;
			Tensor f2 = 0.5 * (F - One) + One;
			Tensor f3 = f1 * Invert(f2);
			Tensor G = 2.0 * (f3 - One);
			Tensor tau = GetTensorFromVector(c(), _Tau);
			Tensor4 C = 2.0 * Mu * I4 + Lambda * DyadicProduct(One, One);
			tau = tau + C*sym(G) + skew(G)*tau - tau*skew(G);
			double Y = sqrt(2.0/3.0) * k_0;
			if (norm(dev(tau)) > Y) {
				double dGamma = 1.0 / 2.0 / Mu * (norm(dev(tau)) - Y ) / (1.0 + 0.5 * h_0);
				Tensor CS = tau - 2 * Mu * dGamma * dev(tau) / norm(dev(tau));
				SetTensorToVector(CS, c(), _CStress);
				SetTensorToVector(CS, c(), _Tau);
			}
			else {
				SetTensorToVector(tau, c(), _CStress);
				SetTensorToVector(tau, c(), _Tau);
			}
		}
	}
}

void FiniteStrainALEAssemble::Jacobi (Matrix& A) {
	A = 0;
	int nc = 0;
	for (cell c = A.GetMesh().cells(); c != A.GetMesh().cells_end(); ++c) {
		VectorFieldElement E(disc, A, c);
		RowEntries A_c(A, E);
		for (int i = 0; i < E.size(); ++i) {
			for (int k = 0; k < dim; ++k) {
				for (int j = 0; j < E.size(); ++j) {
					for (int l = 0; l < dim; ++l) {
						for (int q = 0; q < E.nQ(); q++) {
							A_c(i,i,k,k) += rho[nc] / E.Area() *
								E.VectorValue(q, i, k) * E.VectorValue(q, j, l) * E.QWeight(q);
						}
					}
				}
			}
		}
		nc++;
	}
	A.ClearDirichletValues();
}

double FiniteStrainALEAssemble::Residual (Vector& b, Vector& CS, double time) {
	b = 0;
	for (cell c = b.GetMesh().cells(); c != b.GetMesh().cells_end(); ++c) {
		VectorFieldElement E(disc, b, c);
		RowValues b_c(b, E);
		for (int i = 0; i < E.size(); ++i) {
			for (int k = 0; k < dim; ++k) {
				for (int q = 0; q < E.nQ(); q++) {
					//-----------------------------------------------------------------------------
					// return mapping
					// k
					Tensor sigma2 = GetTensorFromVector(E.QPoint(q), CS);
					//-----------------------------------------------------------------------------
					b_c(i, k) += -1.0 * Frobenius(sym(E.VectorGradient(q, i, k)), sigma2) * E.QWeight(q);
				}
			}
		}
		// F'(x)(x'-x) + F(x) = 0  : F(x)
		for (int i = 0; i < E.size(); ++i) {
			for (int k = 0; k < dim; ++k) {
				for (int q = 0; q < E.nQ(); q++) {
					b_c(i, k) += E.VectorValue(q, i, k) * Source(E.QPoint(q), time) * E.QWeight(q);
				}
			}
		}
		// F'(x)(x'-x) + F(x) = 0  : F(x)
		RowBndValues u_c(b, c);	    
		if (!u_c.onBnd()) continue;
		for (int i = 0; i < c.Faces(); ++i) {
			if (!IsDirichlet(u_c.bc(i)) && u_c.bc(i) != -1) {
				VectorFieldFaceElement E(disc, b, c, i);
				for (int j = 0; j < disc.NodalPointsOnFace(c,i); ++j) {
					int k = disc.NodalPointOnFace(c,i,j);
					for (int l = 0; l < dim; l++) {
						for (int q = 0; q < E.nQ(); q++) {
							u_c(k, l) += E.VectorValue(q, j, l) * Neumann(E.QPoint(q), time, u_c.bc(i)) * E.QWeight(q);
						}
					}
				}			
			}
		}
	}
	b.ClearDirichletValues();
	Collect(b);
}

void FiniteStrainALEAssemble::TESolver (Meshes& M2, int num, double dT) {  
	time_k = dT;
	SetSubDomain(M2.fine());
	if (num==1) SetBoundaryType(M2.fine(), num*dT);
	else {
		if (example_id==15) {
			SetBoundaryType(M2.fine(), num*dT);
		}
		else MeshBndImport (M2);
	}
	
	int dim = M2.dim();
	Discretization disc(dim);
	MatrixGraphs G(M2, disc);
	Vector gd(G.fine());
	Vector x0(gd);
	Vector x1(gd);
	Vector x2(gd);
	Vector x3(gd);
	Matrix A(gd);
	Vector b(gd);
	A = 0;
	b = 0;
	gd = 0;
	x0 = 0;
	x1 = 0;
	x2 = 0;
	x3 = 0;
	Vector TDisp(gd);
	Vector RDisp(gd);
	TDisp = 0;
	RDisp = 0;
	
	int nq = disc.GetQuad((M2.fine()).cells()).size();
	Discretization disc_scalar("cell", 1*nq);
	Discretization disc_vector("cell", 3*nq);
	Discretization disc_tensor("cell", 9*nq);
	MatrixGraphs G_scalar(M2, disc_scalar);
	MatrixGraphs G_vector(M2, disc_vector);
	MatrixGraphs G_tensor(M2, disc_tensor);
	Vector Tau(G_tensor.fine());
	Vector CStress(G_tensor.fine());
	Tau = 0;
	CStress = 0;
	
	// ***********************************************************
	// *****  update configuration *******************************	
	SetDirichlet(gd, num*dT);
	
	if (num==1) {
		SetH0(x0);
		SetH1(x1, dT);
		for (cell c=M2.fine().Cells::cells(); c!=M2.fine().Cells::cells_end(); c++) {
			VectorFieldElement E(disc, A, c);
			rho.push_back(1.0 * E.Area());
		}
		Update(RDisp, Tau, CStress);
	}
	else {
		DispImport(x0, x1);
		PhysicsImport(Tau);		
		PhysicsImport(TDisp, RDisp);
		Update(RDisp, Tau, CStress);
	}
	for (row r=gd.rows(); r!=gd.rows_end(); r++) {
		for (int i=0; i<dim; i++) {
			if (gd.D(r,i)==true) {
				gd(r,i) = (gd(r,i) - 2*x1(r,i) + x0(r,i)) / dT / dT;
			}
		}
	}
	// ***********************************************************
	// **********  solver ******** *******************************
	
	Jacobi(A);
	Residual(b, CStress, num*dT);
	
	Solver S;
	S(A);
	x2 = 0;
	S.multiply_plus(x2, b);
	x2 += gd;
	
	for (row r=x3.rows(); r!=x3.rows_end(); r++) {
		for (int i=0; i<dim; i++) {
			x3(r,i) = dT*dT*x2(r,i) + 2*x1(r,i) - x0(r,i);
		}
	}
	
	// ***********************************************************
	// *****  update configuration *******************************	
	
	// hypla don't use dynamic explicit, very smart for me !!!
	if (!ngeom) {
		x0 = x1;
		x1 = x3;
	}
	else {
		x0 = -1.0*x3;
		x1 = 0;
	}

	// **************************************
	// *********  plot  *********************	
	if (num%frame==0) {
		Plot P(M2.fine());
		string filename1;
		string filename2;
		if (ale) {
			filename1 = string("ale_deform") + to_string(num/frame);
			filename2 = string("ale_undeform") + to_string(num/frame);
		}
		else {
			filename1 = string("ng_deform") + to_string(num/frame);
			filename2 = string("ng_undeform") + to_string(num/frame);
		}
		if (!ngeom) {
			P.vertexdata(TDisp, dim);
		}
		else {
			P.vertexdata(TDisp, dim);
		}
		P.vtk_vertex_vector(filename1.c_str(), 0, 1);
		P.vtk_vertex_vector(filename2.c_str(), 0, 0);
	}
	// **************************************
	
	for (row r=x3.rows(); r!=x3.rows_end(); r++) {
		if (!ngeom) {
			TDisp(r,0) = x3(r,0);
			TDisp(r,1) = x3(r,1);
		}
		else {
			TDisp(r,0) += x3(r,0);
			TDisp(r,1) += x3(r,1);
		}
		RDisp(r,0) = x3(r,0);
		RDisp(r,1) = x3(r,1);
	}
	
	if (!ngeom) x3=0;
	
	MeshExport(x3);
	DispExport(x0, x1, x3);
	PhysicsExport(Tau);
	PhysicsExport(TDisp, RDisp);
}

void FiniteStrainALEAssemble::ALEPre (int i) {
	if (ale) {
		if (i%frame==0) {
			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
			// >>>>>>> rezoning            >>>>>>>
			// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
			AM1 = {num_vertices, coords, num_cells, ids, fixed};
			//ALEMesh2VTK(AM1, string("./data/vtk/mesh_original_")+to_string(i/frame)+string(".vtk"));
			Rezoning(AM1, AM2, i/frame);
			//ALEMesh2VTK(AM2, string("./data/vtk/mesh_smoothing_")+to_string(i/frame)+string(".vtk"));
			
			int ale_test = 0;
			ReadConfig(Settings, "ALETest", ale_test);
			if (ale_test) {
				// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
				// >>>>>>> remapping for cells >>>>>>>
				// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
				double* data1 = new double[num_cells];
				for (int j=0; j<num_cells; j++) {
				data1[j] = cells[j][0] + cells[j][1];
				//data1[j] = 1;
				}
				double* data2 = new double[num_cells];
				test_remapping_cell(data1, data2, i/frame);
				
				// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
				// >>>>>>> remapping for nodes >>>>>>>
				// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
				data1 = new double[num_vertices];
				for (int j=0; j<num_vertices; j++) {
					data1[j] = coords[j*3] + coords[j*3+1];
					//data1[j] = 1;
				}
				data2 = new double[num_vertices];
				test_remapping_node(data1, data2, i/frame);
				//double stop; std::cin >> stop;
			}
			else {
				ale_rezoning();
				ale_remapping_node(disp0, i/frame); 
				ale_remapping_node(disp1, i/frame); 
				ale_remapping_node(TotalDisp, i/frame);
				ale_remapping_node(RefDisp, i/frame);  
				ale_remapping_cell(rho, i/frame);
				ale_remapping_cell(taus, i/frame);
			}
		}
	}
}

void FiniteStrainALEMain () {
	Date Start;	
	double T = 1;
    double nT = 1;
    double dT = 1;
    ReadConfig(Settings, "Time", T);
    ReadConfig(Settings, "TimeSteps", nT);
    dT = T / nT;

	int ng = 0;
	ReadConfig(Settings, "NGeom", ng);
	int ale = 0;
	ReadConfig(Settings, "ALE", ale);
	
	mout << "*************** " << 1 << " ******************" << endl;
	string name = "UnitCube";
	ReadConfig(Settings, "Mesh", name);
	Meshes M(name.c_str());
	FiniteStrainALEAssemble EPA(M.dim());
	EPA.SetNGeom(ng);
	EPA.SetALE(ale);
	EPA.TESolver(M, 1, dT);
	
	for (int i=2; i<nT+1; i++) {
		mout << "*************** " << i << " ******************" << endl;
		EPA.ALEPre(i);
		Meshes M2(EPA.coords, EPA.num_vertices*3, EPA.ids, EPA.num_cells*4);
		EPA.TESolver(M2, i, dT);
	}
    tout(1) << Date() - Start << endl;
    return;    
}
