#include "FiniteStrainALE.h"
#include "Remapping.h"

void FiniteStrainALEAssemble::MeshExport (const Vector& x1) {
	if (coords!=NULL) {
		delete coords;
		coords = NULL;
	}
	if (ids!=NULL) {
		delete ids;
		ids = NULL;
	}
	if (fixed!=NULL) {
		delete fixed;
		fixed = NULL;
	}
	cells.clear();
	// vertices
	num_vertices = x1.GetMesh().Vertices::size();
	coords = new double[num_vertices*3];
	vertices.clear();
	vertices.resize(num_vertices);
	int dim = x1.GetMesh().dim();
	for (row r=x1.rows(); r!=x1.rows_end(); r++) {
		Point p = Point(r()+x1(r));
		for (int i=0; i<dim; i++) {
			coords[r.Id()*3+i] = p[i];
		}
		vertices[r.Id()] = Point(p[0],p[1]);
		if (dim<3) coords[r.Id()*3+2] = 0;
	}
	// cells
	num_cells = x1.GetMesh().Cells::size();
	ids = new int[num_cells*4];
	int i = 0;
	for (cell c=x1.GetMesh().cells(); c!=x1.GetMesh().cells_end(); c++) {
		for (int j=0; j<c.Corners(); j++) {
			ids[i*4+j] = x1.Id(c.Corner(j));
		}
		i++;
		Point p1 = c.Corner(0) + Point(x1(c.Corner(0),0),x1(c.Corner(0),1));
		Point p2 = c.Corner(1) + Point(x1(c.Corner(1),0),x1(c.Corner(1),1));
		Point p3 = c.Corner(2) + Point(x1(c.Corner(2),0),x1(c.Corner(2),1));
		Point p4 = c.Corner(3) + Point(x1(c.Corner(3),0),x1(c.Corner(3),1));
		Point p = 0.25 * (p1 + p2 + p3 + p4);
		cells.push_back(Point(p[0],p[1]));
	}
	// fixed points
	fixed = new bool[num_vertices];
	for (int i=0; i<num_vertices; i++) fixed[i] = 0;
	for (bnd_face bf=x1.bnd_faces(); bf!=x1.bnd_faces_end(); bf++) {
		Point left = x1.GetMesh().find_face(bf()).Left();
		cell c = x1.GetMesh().find_cell(left);
		for (int i=0; i<c.Faces(); i++) {
			if (c.Face(i) == bf()) {
				for (int j=0; j<c.FaceCorners(i); j++) {
					fixed[x1.Id(c.FaceCorner(i,j))] = 1;
				}
			}
		}
	}
	// boundary faces
	bnds.clear();
	bndsid.clear();
	for (bnd_face bf=x1.bnd_faces(); bf!=x1.bnd_faces_end(); bf++) {
		Point left = x1.GetMesh().find_face(bf()).Left();
		cell c = x1.GetMesh().find_cell(left);
		for (int i=0; i<c.Faces(); i++) {
			if (c.Face(i) == bf()) {
				Point bnd;
				for (int j=0; j<c.FaceCorners(i); j++) {
					bnd += c.FaceCorner(i,j) + x1(c.FaceCorner(i,j));
				}
				bnd[2] = 0;
				bnd *= 1.0 / c.FaceCorners(i);
				bnds.push_back(bnd);
				bndsid.push_back(bf.Part());
			}
		}
	}
}

void FiniteStrainALEAssemble::MeshBndImport (Meshes& M2) {
	for (int i=0; i<bnds.size(); i++) {
		hash_map<Point,BoundaryFace,Hash>::iterator it = M2.fine().BoundaryFaces::find(bnds[i]);
		it->second.SetPart(bndsid[i]);
	}
}

void FiniteStrainALEAssemble::DispExport (const Vector& x0, const Vector& x1, const Vector& x3) {
	disp0.clear();
	disp1.clear();
	disp0.resize(vertices.size());
	disp1.resize(vertices.size());
	for (row r = x3.rows(); r != x3.rows_end(); r++) {
		Point d = x3(r);
		d += r();
		disp0[r.Id()]=Point(x0(r)[0],x0(r)[1]);
		disp1[r.Id()]=Point(x1(r)[0],x1(r)[1]);
	}
}

void FiniteStrainALEAssemble::DispImport (Vector& x0, Vector& x1) {
	for (int i=0; i<vertices.size(); i++) {
		x0(vertices[i],0) = disp0[i][0];
		x0(vertices[i],1) = disp0[i][1];
		x1(vertices[i],0) = disp1[i][0];
		x1(vertices[i],1) = disp1[i][1];
	}
}

void FiniteStrainALEAssemble::PhysicsExport (const Vector& Tau) {
	taus.clear();
	for (cell c = Tau.GetMesh().cells(); c != Tau.GetMesh().cells_end(); ++c) {
		VectorFieldElement E(disc, Tau, c);
		for (int q = 0; q < E.nQ(); q++) {
			// incremental strain
			Tensor s = Tensor(Tau(E.QPoint(q),0),
							  Tau(E.QPoint(q),1),
							  Tau(E.QPoint(q),2),
							  Tau(E.QPoint(q),3),
							  Tau(E.QPoint(q),4),
							  Tau(E.QPoint(q),5),
							  Tau(E.QPoint(q),6),
							  Tau(E.QPoint(q),7),
							  Tau(E.QPoint(q),8));
			taus.push_back(s);
		}
	}
}

void FiniteStrainALEAssemble::PhysicsImport (Vector& Tau) {
	for (int i=0; i<cells.size(); i++) {
		Point p(cells[i][0],cells[i][1]);
		// incremental plastic strain
		Tau(p,0) = taus[i][0][0];
		Tau(p,1) = taus[i][0][1];
		Tau(p,2) = taus[i][0][2];
		Tau(p,3) = taus[i][1][0];
		Tau(p,4) = taus[i][1][1];
		Tau(p,5) = taus[i][1][2];
		Tau(p,6) = taus[i][2][0];
		Tau(p,7) = taus[i][2][1];
		Tau(p,8) = taus[i][2][2];
	}	
}

void FiniteStrainALEAssemble::PhysicsExport (const Vector& TDisp, const Vector& RDisp) {
	TotalDisp.clear();
	RefDisp.clear();
	TotalDisp.resize(vertices.size());
	RefDisp.resize(vertices.size());
	for (row r = TDisp.rows(); r != TDisp.rows_end(); ++r) {
		Point p;
		p[0] = TDisp(r,0);
		p[1] = TDisp(r,1);
		TotalDisp[r.Id()] = p;
		p[0] = RDisp(r,0);
		p[1] = RDisp(r,1);
		RefDisp[r.Id()] = p;
	}
}

void FiniteStrainALEAssemble::PhysicsImport (Vector& TDisp, Vector& RDisp) {
	for (int i=0; i<vertices.size(); i++) {
		Point p(vertices[i][0],vertices[i][1]);
		TDisp(p,0) = TotalDisp[i][0];
		TDisp(p,1) = TotalDisp[i][1];
		RDisp(p,0) = RefDisp[i][0];
		RDisp(p,1) = RefDisp[i][1];
	}	
}

void FiniteStrainALEAssemble::ale_rezoning() {
	num_vertices = AM2.num_vertices;
	coords = AM2.coords;
	num_cells = AM2.num_cells;	
	ids = AM2.ids;
	fixed = AM2.fixed;
	vertices.clear();
	vertices.resize(num_vertices);
	for (int n=0; n<num_vertices; n++) {
		vertices[n] = Point(coords[3*n],coords[3*n+1]);
	}
	cells.clear();
	cells.resize(num_cells);
	for (int n=0; n<num_cells; n++) {
		int m = ids[4*n];
		Point p1(coords[3*m],coords[3*m+1]);
		m = ids[4*n+1];
		Point p2(coords[3*m],coords[3*m+1]);
		m = ids[4*n+2];
		Point p3(coords[3*m],coords[3*m+1]);
		m = ids[4*n+3];
		Point p4(coords[3*m],coords[3*m+1]);
		cells[n] = 0.25*(p1+p2+p3+p4);
	}	
}

void FiniteStrainALEAssemble::ale_remapping_cell(vector<double>& A, int n) {
	double* data1 = new double[A.size()];
	double* data2 = new double[A.size()];
	for (int j=0; j<A.size(); j++) {
		data1[j] = A[j];
	}
	test_remapping_cell(data1, data2, n);
	for (int j=0; j<A.size(); j++) {
		A[j] = data2[j];
	}
}

void FiniteStrainALEAssemble::ale_remapping_cell(vector<Point>& A, int n) {
	for (int i=0; i<dim; i++) {
		double* data1 = new double[A.size()];
		double* data2 = new double[A.size()];
		for (int j=0; j<A.size(); j++) {
			data1[j] = A[j][i];
		}
		test_remapping_cell(data1, data2, n);
		for (int j=0; j<A.size(); j++) {
			A[j][i] = data2[j];
		}
	}
}

void FiniteStrainALEAssemble::ale_remapping_cell(vector<Tensor>& A, int n) {
	for (int i=0; i<3; i++) {
		for (int j=0; j<3; j++) {
			double* data1 = new double[A.size()];
			double* data2 = new double[A.size()];
			for (int k=0; k<A.size(); k++) {
				data1[k] = A[k][i][j];
			}
			test_remapping_cell(data1, data2, n);
			for (int k=0; k<A.size(); k++) {
				A[k][i][j] = data2[k];
			}
		}
	}
}

void FiniteStrainALEAssemble::ale_remapping_node(vector<Point>& A, int n) {
	for (int i=0; i<dim; i++) {
		double* data1 = new double[A.size()];
		double* data2 = new double[A.size()];
		for (int j=0; j<A.size(); j++) {
			data1[j] = A[j][i];
		}
		test_remapping_node(data1, data2, n);
		for (int j=0; j<A.size(); j++) {
			A[j][i] = data2[j];
		}
	}
}


