#include "Rezoning.h"
#include "Mesquite_all_headers.hpp"
#include <ostream>
using namespace Mesquite;

void Rezoning1 (Mesquite::MeshImpl& my_mesh);
void Rezoning2 (Mesquite::MeshImpl& my_mesh);
void Rezoning3 (Mesquite::MeshImpl& my_mesh);

class MyMesh : public MeshImpl {
	MsqError err;
public:
	MyMesh (MeshImpl S) : MeshImpl(S) {}
	MyMesh (int num_vertices, int num_cells, int n, bool* fixed, double* coords, int* ids) :
		MeshImpl(num_vertices, num_cells, EntityTopology(9), fixed, coords, ids) {}
	MyMesh (ALEMesh AM) :
		MeshImpl(AM.num_vertices, AM.num_cells, EntityTopology(9), AM.fixed, AM.coords, AM.ids) {}
	void DataExport (ALEMesh& AM) {
		AM.num_vertices = myMesh->num_vertices();
		AM.coords = new double[3*myMesh->num_vertices()];
		for (int i=0; i<myMesh->num_vertices(); i++) {
			Vector3D coords = myMesh->get_vertex_coords(i, err);
			AM.coords[i*3+0] =  coords[0];
			AM.coords[i*3+1] =  coords[1];
			AM.coords[i*3+2] =  coords[2];
		}
		AM.num_cells = myMesh->num_elements();
		AM.ids = new int[4*myMesh->num_elements()];
		for (int i=0; i<myMesh->num_elements(); i++) {
			std::vector<size_t> conn = myMesh->element_connectivity(i, err);
			AM.ids[i*4+0] =  conn[0];
			AM.ids[i*4+1] =  conn[1];
			AM.ids[i*4+2] =  conn[2];
			AM.ids[i*4+3] =  conn[3];
		}
		AM.fixed = new bool[myMesh->num_vertices()];
		for (int i=0; i<myMesh->num_vertices(); i++) {
			AM.fixed[i] = myMesh->vertex_is_fixed(i, err);
		}		
	}
};

// *******************************************
// ****
// the example for wrappers from user's guide chapter 7
// ****
// *******************************************
void Rezoning1 (Mesquite::MeshImpl& my_mesh) {
	MsqError err;
	Vector3D normal(0,0,1);
	Vector3D point(0,0,0);
	PlanarDomain my_mesh_plane(normal, point);
	MeshDomainAssoc mesh_and_domain = MeshDomainAssoc(&my_mesh, &my_mesh_plane);
	//LaplaceWrapper smoother;
	//smoother.set_vertex_movement_limit_factor(0.1);
	//smoother.set_iteration_limit(1000);
	ShapeImprover smoother;
	smoother.set_vertex_movement_limit_factor(1e-3);
	//PaverMinEdgeLengthWrapper smoother(1e-2,1000);
	//UntangleWrapper smoother;
	//SizeAdaptShapeWrapper smoother(1e-2,1000);
	smoother.run_instructions(&mesh_and_domain, err);
	
	if (err) {
		std::cout << err << std::endl;
	}
}

// *******************************************
// ****
// the example for mesquite features from user's guide chapter 5
// 
// ****
// *******************************************
void Rezoning2 (Mesquite::MeshImpl& my_mesh) {
	MsqError err;
	// creates an intruction queue
	InstructionQueue queue1;
	
    // creates a mean ratio quality metric ...
	ConditionNumberQualityMetric shape_metric;
	EdgeLengthQualityMetric lapl_met;
	lapl_met.set_averaging_method(QualityMetric::RMS);
	
    // creates the laplacian smoother  procedures
	LaplacianSmoother lapl1;
	QualityAssessor stop_qa=QualityAssessor(&shape_metric);
	stop_qa.add_quality_assessment(&lapl_met);
	
    //**************Set stopping criterion****************
	TerminationCriterion sc2;
	sc2.add_iteration_limit( 1000 );
	//if (err) return 1;
	lapl1.set_outer_termination_criterion(&sc2);
	
    // adds 1 pass of pass1 to mesh_set1
	queue1.add_quality_assessor(&stop_qa,err); 
	//if (err) return 1;
	queue1.set_master_quality_improver(&lapl1, err); 
	//if (err) return 1;
	queue1.add_quality_assessor(&stop_qa,err); 
	//if (err) return 1;
	
	PlanarDomain plane(Vector3D(0,0,1), Vector3D(0,0,0));
  
    // launches optimization on mesh_set1
	MeshDomainAssoc mesh_and_domain = MeshDomainAssoc(&my_mesh, &plane);
	Timer t;
	queue1.run_instructions(&mesh_and_domain, err);
	//if (err) return 1;
	double secs = t.since_birth();
	std::cout << "Optimization completed in " << secs << " seconds" << std::endl;
	
}

// *******************************************
// ****
// the example for using the local and global
// optimization
// ****
// *******************************************
void Rezoning3 (Mesquite::MeshImpl& my_mesh) {
    MsqError err;		
	Vector3D normal(0,0,1);
	Vector3D point(0,0,0);
	PlanarDomain my_mesh_plane(normal, point);
	
    // creates a mean ratio quality metric ...
	IdealWeightInverseMeanRatio inverse_mean_ratio(err);
    // sets the objective function template
	LPtoPTemplate obj_func(&inverse_mean_ratio, 2, err);
	// creates the optimization procedures
	SteepestDescent f_newton(&obj_func);
    //performs optimization globally
	f_newton.use_global_patch();
	// creates the optimization procedures
	TrustRegion t_region(&obj_func);
	//performs optimization globally
	t_region.use_global_patch();
    // creates a termination criterion and
    // add it to the optimization procedure
    // outer loop: default behavior: 1 iteration
    // inner loop: stop if gradient norm < eps
	TerminationCriterion tc_inner;
	tc_inner.add_absolute_gradient_L2_norm( 1e-4 );
	tc_inner.add_iteration_limit( 1000 );
	t_region.set_inner_termination_criterion(&tc_inner);

	
    // creates a quality assessor
	QualityAssessor m_ratio_qa(&inverse_mean_ratio);
    // creates an instruction queue
	InstructionQueue queue;
	queue.set_master_quality_improver(&t_region, err);
	queue.add_quality_assessor(&m_ratio_qa, err);



	


	
// do optimization of the mesh_set
	MeshDomainAssoc mesh_and_domain = MeshDomainAssoc(&my_mesh, &my_mesh_plane);
	queue.run_instructions(&mesh_and_domain, err);
	if (err) {
		std::cout << err << std::endl;
		//return 2;
	}

	
	//return 0;

}


// *******************************************
// ****
// the example for using the local and global
// optimization
// ****
// *******************************************
void Rezoning4 (Mesquite::MeshImpl& mesh) {
	MsqError err;		
	std::vector<Mesh::VertexHandle> verts;
	mesh.get_all_vertices( verts, err );
	//if (err || verts.empty()) return 1;
	MsqVertex coords;
	mesh.vertices_get_coordinates( arrptr(verts), &coords, 1, err );
	//if (err) return 1;
	Vector3D norm(0,0,1);
	PlanarDomain u_domain( norm, coords );
	
	UntangleWrapper::UntangleMetric metric = UntangleWrapper::BETA;
	UntangleWrapper un_wrapper (metric);
	un_wrapper.set_vertex_movement_limit_factor( 0.005 );
	
	MeshDomainAssoc mesh_and_domain3 = MeshDomainAssoc(&mesh, &u_domain);
	//t.reset();
	un_wrapper.run_instructions( &mesh_and_domain3, err );
	//if (err) return 1;
}




void Rezoning (const ALEMesh& AM1, ALEMesh& AM2, int n) {
	MsqError err;		
	MyMesh my_mesh(AM1);
	//my_mesh.write_vtk((std::string("./data/vtk/source_")+std::to_string(n)+std::string(".vtk")).c_str(), err);
	my_mesh.write_exodus((std::string("./data/vtk/source_")+std::to_string(n)+std::string(".exo")).c_str(), err);
	Rezoning1(my_mesh);
	//my_mesh.write_vtk((std::string("./data/vtk/target_")+std::to_string(n)+std::string(".vtk")).c_str(), err);
	my_mesh.write_exodus((std::string("./data/vtk/target_")+std::to_string(n)+std::string(".exo")).c_str(), err);
	my_mesh.DataExport(AM2);
}

void RezoningMain () {
	MsqError err;		
	MeshImpl my_mesh;
	my_mesh.read_vtk("./data/vtk/origin.vtk", err);
	Rezoning1(my_mesh);
	my_mesh.write_vtk("./data/vtk/smoothing.vtk", err);


	return;
  
	ALEMesh M1;
	ALEMesh M2;
	VTK2ALEMesh("./solver/conf/geo/ale_test.vtk",M1);
	Rezoning(M1,M2);
	ALEMesh2VTK(M2,"./data/vtk/mesh_smoothing.vtk");
}

void ALEMesh2Exo (const ALEMesh& AM, std::string file_name) {
	MsqError err;		
	MyMesh my_mesh(AM);
	my_mesh.write_exodus(file_name.c_str(), err);
}
