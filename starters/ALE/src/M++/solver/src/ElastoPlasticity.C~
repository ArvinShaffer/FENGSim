// file: ElastoPlasticity.C
// author: Jiping Xin
// This module is to solve elastoplasticity problem
// by using the Newton method and the return mapping algorithm.

#include "ElastoPlasticity.h"

ElastoPlasticityAssemble::ElastoPlasticityAssemble (int _dim) : disc(Discretization(_dim)) {
	dim = _dim;
	Mu = mu;
	Lambda = lambda;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			I4.set(i, j, Tensor(i,j));
		}
	}
}

void ElastoPlasticityAssemble::Dirichlet (Vector& u, double t) {
	u.ClearDirichletFlags();
	for (cell c = u.GetMesh().cells(); c != u.GetMesh().cells_end(); ++c) {	  
		RowBndValues u_c(u, c);	    
		if (!u_c.onBnd()) continue;
		for (int i = 0; i < c.Faces(); ++i) {
			if (!IsDirichlet(u_c.bc(i))) continue;
			VectorFieldElement E(disc, u, c);
			for (int j = 0; j < disc.NodalPointsOnFace(c,i); ++j) {
				int k = disc.NodalPointOnFace(c, i, j);
				SetDirichlet(E[k](), t, k, u_c, u_c.bc(i));
			}
		}
	}
	DirichletConsistent(u);
}

void ElastoPlasticityAssemble::Update (const Tensor epsilon2, const Tensor epsilonp1, const double alpha1, const Tensor beta1,
									   Tensor& epsilonp2, double& alpha2, Tensor& beta2, Tensor4& C2, Tensor& sigma2) {    
	Tensor4 J1;
	Tensor4 J2;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			J1.set(i, j, Tensor(i,j));
		}
		J2.set(i, i, One);
	}
	Tensor4 Dev = J1 - 1.0 / 3.0 * J2;
	Tensor T = 2.0 * Mu * (epsilon2 - epsilonp1) + Lambda * trace(epsilon2 - epsilonp1) * One;
	Tensor S = dev(T);
	
	Tensor N;
	if (norm(S) == 0) N = Zero;
	else N = 1.0 / norm(S) * S;
	
	double d;
	if (norm(S) == 0) d = 0;
	else d = 1.0 / norm(S);
	
	Tensor4 C;
	C = 2.0 * Mu * I4 + Lambda * DyadicProduct(One, One);
	
	double Y = Mu * h_0 * alpha1 + sqrt(2.0/3.0) * k_0;
	double dGamma = 1.0 / 2.0 / Mu * (norm(S) - Y ) / (1.0 + 0.5 * h_0);
	
	if (norm(S) > Y) {
		epsilonp2 = epsilonp1 + dGamma * N;
		alpha2 = alpha1 + dGamma;
		sigma2 = C * (epsilon2 - epsilonp2);
		C2 = 2.0 * Mu * I4 + Lambda * DyadicProduct(One, One)
			- (2.0 * Mu / (1.0 + 0.5 * h_0)) * DyadicProduct(N, N)
			- 4.0 * Mu * Mu * dGamma * d * (Dev - DyadicProduct(N, N))
			;
	}
	else {
		epsilonp2 = epsilonp1;
		alpha2 = alpha1;
		sigma2 = T;
		C2 = C;
	}
}

void ElastoPlasticityAssemble::Update (Vector& x, Vector& EpsilonP1, Vector& Alpha1, Vector& Beta1) {
	for (cell c = x.GetMesh().cells(); c != x.GetMesh().cells_end(); c++) {
		VectorFieldElement E(disc, x, c);
		for (int q = 0; q < E.nQ(); q++) {
			//-----------------------------------------------------------------------------
			// return mapping
			// k
			Tensor epsilon2 = sym(E.VectorGradient(q, x));
			Tensor epsilonp1 = GetTensorFromVector(c(), EpsilonP1, q);
			double alpha1 = Alpha1(c(), q);
			Tensor beta1 = GetTensorFromVector(c(), Beta1, q);
			// k + 1
			Tensor epsilonp2;
			double alpha2;
			Tensor beta2;
			Tensor4 C2;
			Tensor sigma2;
			Update(epsilon2, epsilonp1, alpha1, beta1,
				   epsilonp2, alpha2, beta2, C2, sigma2);
			//-----------------------------------------------------------------------------
			Alpha1(c(), q) = alpha2;
			SetTensorToVector(beta2, c(), Beta1, q);
			SetTensorToVector(epsilonp2, c(), EpsilonP1, q);
		}
	}
}

void ElastoPlasticityAssemble::Jacobi (Matrix& A, Vector& x0, Vector& EpsilonP1, Vector& Alpha1, Vector& Beta1) {
	A = 0;
	for (cell c = A.GetMesh().cells(); c != A.GetMesh().cells_end(); ++c) {
		VectorFieldElement E(disc, A, c);
		RowEntries A_c(A, E);
		for (int i = 0; i < E.size(); ++i) {
			for (int j = 0; j < E.size(); ++j) {
				for (int k = 0; k < dim; ++k) {
					for (int l = 0; l < dim; ++l) {
						for (int q = 0; q < E.nQ(); q++) {
							//-----------------------------------------------------------------------------
							// return mapping
							// k
							Tensor epsilon2 = sym(E.VectorGradient(q, x0));
							Tensor epsilonp1 = GetTensorFromVector(c(), EpsilonP1, q);
							double alpha1 = Alpha1(c(), q);
							Tensor beta1 = GetTensorFromVector(c(), Beta1, q);
							// k + 1
							Tensor epsilonp2;		
							double alpha2;
							Tensor beta2;
							Tensor4 C2;
							Tensor sigma2;				
							Update(epsilon2, epsilonp1, alpha1, beta1,
								   epsilonp2, alpha2, beta2, C2, sigma2);
							//-----------------------------------------------------------------------------
							A_c(i,j,k,l) += Frobenius(sym(E.VectorGradient(q, i, k)), C2*sym(E.VectorGradient(q, j, l))) * E.QWeight(q);
						}
					}
				}
			}
		}
	}
	A.ClearDirichletValues();
}

double ElastoPlasticityAssemble::Residual (Vector& b, Vector& x0, Vector& EpsilonP1, Vector& Alpha1, Vector& Beta1,
										   double time) {
	b = 0;
	for (cell c = b.GetMesh().cells(); c != b.GetMesh().cells_end(); ++c) {
		VectorFieldElement E(disc, b, c);
		RowValues b_c(b, E);
		// F'(x)(x'-x) + F(x) = 0  : F(x)
		for (int i = 0; i < E.size(); ++i) {
			for (int k = 0; k < dim; ++k) {
				for (int q = 0; q < E.nQ(); q++) {
					//-----------------------------------------------------------------------------
					// return mapping
					// k
					Tensor epsilon2 = sym(E.VectorGradient(q, x0));
					Tensor epsilonp1 = GetTensorFromVector(c(), EpsilonP1, q);
					double alpha1 = Alpha1(c(), q);
					Tensor beta1 = GetTensorFromVector(c(), Beta1, q);
					// k + 1
					Tensor epsilonp2;
					double alpha2;
					Tensor beta2;
					Tensor4 C2;
					Tensor sigma2;
					Update(epsilon2, epsilonp1, alpha1, beta1,
						   epsilonp2, alpha2, beta2, C2, sigma2);
					//-----------------------------------------------------------------------------
					b_c(i, k) += -1.0 * Frobenius(sym(E.VectorGradient(q, i, k)), sigma2) * E.QWeight(q);
				}
			}
		}
		// F'(x)(x'-x) + F(x) = 0  : F(x)
		for (int i = 0; i < E.size(); ++i) {
			for (int k = 0; k < dim; ++k) {
				for (int q = 0; q < E.nQ(); q++) {
					b_c(i,k) += E.VectorValue(q, i, k) * SetSource(E.QPoint(q), time) * E.QWeight(q);
				}
			}
		}
		// F'(x)(x'-x) + F(x) = 0  : F(x)
		RowBndValues u_c(b, c);	    
		if (!u_c.onBnd()) continue;
			for (int i = 0; i < c.Faces(); ++i) {
				if (!IsDirichlet(u_c.bc(i)) && u_c.bc(i) != -1) {
					VectorFieldFaceElement E(disc, b, c, i);
					for (int j = 0; j < disc.NodalPointsOnFace(c,i); ++j) {
						int k = disc.NodalPointOnFace(c,i,j);
						for (int l = 0; l < dim; l++) {
							for (int q = 0; q < E.nQ(); q++) {
								u_c(k,l) += E.VectorValue(q, j, l) * SetNeumann(E.QPoint(q), time, u_c.bc(i)) * E.QWeight(q);
							}
						}
					}			
				}
			}
	}
	b.ClearDirichletValues();
	Collect(b);
}

double ElastoPlasticityAssemble::L2Error (const Vector& x) {
	double t = 0;
	for (cell c = x.GetMesh().cells(); c != x.GetMesh().cells_end(); c++) {
		VectorFieldElement E(disc,x,c);
		for (int q = 0; q < E.nQ(); q++) {
			Point p = SetSolution(E.QPoint(q));
			t += (E.VectorValue(q,x) - p) * (E.VectorValue(q,x) - p) * E.QWeight(q);
		}
	}
	t = PPM->Sum(t);
	return sqrt(t);
}

void ElastoPlasticityAssemble::AnalyticalSolution (const Vector& x, double c, double dim) {
	if (dim == 2) {
		if (x.find_row(Point(2, 0, 0)) != x.rows_end()) {
			cout << ">>---------------------------------------------------------------<<" << endl;
			double a = 1.0;
			double b = 2.0;
			double Y = 0.24 * 2.0 / sqrt(3.0);
			double pa = Y * (log(c / a) + 0.5 * (1.0 - c * c / b / b)) ;
			double dis = Y * c * c / Young / b * (1.0 - PoissonRatio * PoissonRatio);
			//cout << "     plasticity begin from: " << Y * (log(a / a) + 0.5 * (1.0 - a * a / b / b)) << endl;
			//cout << "     collapse begin from: " << Y * (log(b / a) + 0.5 * (1.0 - b * b / b / b)) << endl;
			cout << "     c: " << c << endl;
			cout << "     pressure: " << pa << endl;
			cout << "     displacement (2,0,0): " << x(Point(2, 0, 0), 0) << " " << x(Point(2, 0, 0), 1) << endl;
			cout << "     analytical plasticity displacement: " << dis << endl;
			cout << ">>---------------------------------------------------------------<<" << endl;
		}
	}
	if (dim == 3) {
		if (x.find_row(Point(2, 0, 0)) != x.rows_end()) {
			cout << ">>---------------------------------------------------------------<<" << endl;
			double a = 1.0;
			double b = 2.0;
			double Y = 0.24;
			double pa = Y * (2.0 * log(c / a) + 2.0 / 3.0 * (1.0 - c * c * c / b / b / b)) ;
			double dis = Y * c * c * c / 3.0 / Young / b / b / b / b / b * (2.0 * (1.0 - 2.0 * PoissonRatio) * b * b * b + (1.0 + PoissonRatio) * b * b * b);
			//cout << "     plasticity begin from: " << Y * (log(a / a) + 0.5 * (1.0 - a * a / b / b)) << endl;
			//cout << "     collapse begin from: " << Y * (log(b / a) + 0.5 * (1.0 - b * b / b / b)) << endl;
			cout << "     c: " << c << endl;
			cout << "     pressure: " << pa << endl;
			cout << "     displacement (2,0,0): " << x(Point(2, 0, 0), 0) << " " << x(Point(2, 0, 0), 1) << endl;
			cout << "     analytical plasticity displacement: " << dis << endl;
			cout << ">>---------------------------------------------------------------<<" << endl;
		}
	}
}

void ElastoPlasticityMain () {
    Date Start;  
    string name = "UnitCube";
    ReadConfig(Settings, "Mesh", name);
    Meshes M(name.c_str());
	ElastoPlasticityAssemble EPA(M.dim());
    EPA.SetSubDomain(M.fine());
    EPA.SetBoundaryType(M.fine());
	
    int dim = M.dim();
    Discretization disc(dim);
    MatrixGraphs G(M, disc);
    Vector x(G.fine());
    Matrix A(x);
    Vector b(x);
    Vector dx(x);
    A = 0;
    b = 0;
    x = 0; // strange x is not zero ??
    dx = 0; // strange x is not zero ??

    int nq = disc.GetQuad((M.fine()).cells()).size();
    Discretization disc_scalar("cell", 1*nq);
    Discretization disc_tensor("cell", 9*nq);
    MatrixGraphs G_scalar(M, disc_scalar);
    MatrixGraphs G_tensor(M, disc_tensor);
    Vector epsilonp1(G_tensor.fine());
    Vector alpha1(G_scalar.fine());
    Vector beta1(G_tensor.fine());
    epsilonp1 = 0;
    alpha1 = 0;
    beta1 = 0;

    EPA.Dirichlet(x,0);
    Solver S;
    double c = 1.5;
	
    Start = Date();
    EPA.Residual(b, x, epsilonp1, alpha1, beta1, c);
    mout << "assemble vector: " << Date() - Start << endl;
    
    for (int k = 0; k < 20; k++) {
        mout << endl << "newton step: " << k << endl;
		
		Start = Date();
		EPA.Jacobi(A, x, epsilonp1, alpha1, beta1);
		mout << "assemble matrix: " << Date() - Start << endl;
		
		Start = Date();
		//S(A);
		//dx = 0;
		//S.multiply_plus(dx, b);
		dx = S(A) * b;
		mout << "linear algebra: " << Date() - Start << endl;
		
		x += dx;
		
		Start = Date();
		EPA.Residual(b, x, epsilonp1, alpha1, beta1, c);
		mout << "assemble vector: " << Date() - Start << endl;
		
		EPA.AnalyticalSolution(x, c, dim);
		
		double res = b.norm();
		mout << "residual: " << res << endl;
		if (res < 1e-8) {
			break;
		}
    }

    EPA.Update(x, epsilonp1, alpha1, beta1); // should be here 
    
    mout << "l2 error: " << EPA.L2Error(x) << endl;
    
    Plot P(M.fine());
    P.vertexdata(x, dim);
    P.vtk_vertex_vector("elastoplasticity_deform", 0, 1);
    P.vtk_vertex_vector("elastoplasticity_undeform", 0, 0);
    
    tout(1) << Date() - Start << endl;
    return;    
}

void QuasiElastoPlasticityMain () {
    Date Start;  
    string name = "UnitCube";
    ReadConfig(Settings, "Mesh", name);
    Meshes M(name.c_str());
	ElastoPlasticityAssemble EPA(M.dim());
    EPA.SetSubDomain(M.fine());
    EPA.SetBoundaryType(M.fine());
	
    int dim = M.dim();
    Discretization disc(dim);
    MatrixGraphs G(M, disc);
    Vector x(G.fine());
    Matrix A(x);
    Vector b(x);
    Vector dx(x);
    A = 0;
    b = 0;
    x = 0; // strange x is not zero ??
    dx = 0; // strange x is not zero ??
	
    int nq = disc.GetQuad((M.fine()).cells()).size();
    Discretization disc_scalar("cell", 1*nq);
    Discretization disc_tensor("cell", 9*nq);
    MatrixGraphs G_scalar(M, disc_scalar);
    MatrixGraphs G_tensor(M, disc_tensor);
    Vector epsilonp1(G_tensor.fine());
    Vector alpha1(G_scalar.fine());
    Vector beta1(G_tensor.fine());
    epsilonp1 = 0;
    alpha1 = 0;
    beta1 = 0;    
	
    Solver S;
    Plot P(M.fine());
    double T = 1;
    double nT = 1;
    double dT = 0.1;
    ReadConfig(Settings, "Time", T);
    ReadConfig(Settings, "TimeSteps", nT);
    dT = T / nT;
    
    for (int i = 0; i < nT + 1; i++) {
        mout << endl;
		mout << "time step: " << i << endl;
		// **************************************************
		// newton
		EPA.Dirichlet(x, i * dT);
		EPA.Residual(b, x, epsilonp1, alpha1, beta1, i * dT);
		for (int k = 0; k < infty; k++) {
			mout << "  newton step: " << k << endl;
			EPA.Jacobi(A, x, epsilonp1, alpha1, beta1);
			dx = S(A) * b; 
			x += dx;
			EPA.Residual(b, x, epsilonp1, alpha1, beta1, i * dT);
			double res = b.norm();
			mout << "  res: " << res << endl;
			if (res < 1e-5) {
				break;
			}
		}
		EPA.Update(x, epsilonp1, alpha1, beta1);
		// **************************************************
		char buffer [10];
		sprintf(buffer,"%d",i);
		string filename1 = string("quasi_elastoplasticity_deform") + buffer;
		string filename2 = string("quasi_elastoplasticity_undeform") + buffer;	
		P.vertexdata(x, dim);
		P.vtk_vertex_vector(filename1.c_str(), 0, 1);
		P.vtk_vertex_vector(filename2.c_str(), 0, 0);
	}
	
	mout << "l2 error: " << EPA.L2Error(x) << endl;

    tout(1) << Date() - Start << endl;
    return;    
}

